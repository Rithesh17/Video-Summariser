WEBVTT - https://subtitletools.com

00:00:00.060 --> 00:00:03.120
in this video we'll talk about the

00:00:01.709 --> 00:00:05.520
second major type of machine learning

00:00:03.120 --> 00:00:07.620
problem called unsupervised learning in

00:00:05.520 --> 00:00:10.349
the last video we talked about

00:00:07.620 --> 00:00:12.809
supervised learning back then we count

00:00:10.349 --> 00:00:16.170
data sets that look like this where each

00:00:12.809 --> 00:00:18.180
example was labeled either as a positive

00:00:16.170 --> 00:00:21.300
or a negative example whether it was a

00:00:18.180 --> 00:00:23.070
benign or a malignant tumor so for each

00:00:21.300 --> 00:00:25.230
example in supervised learning we were

00:00:23.070 --> 00:00:27.510
told explicitly what is the so-called

00:00:25.230 --> 00:00:30.210
right answer whether it's benign or

00:00:27.510 --> 00:00:32.130
malignant in unsupervised learning we're

00:00:30.210 --> 00:00:34.500
given data that looks different in green

00:00:32.130 --> 00:00:36.300
data that looks like this that doesn't

00:00:34.500 --> 00:00:39.930
have any labels or that of all has the

00:00:36.300 --> 00:00:41.940
same label or really no labels so we're

00:00:39.930 --> 00:00:43.980
given the data set and we're not told

00:00:41.940 --> 00:00:46.140
what to do a bit and we're not told what

00:00:43.980 --> 00:00:48.780
each data point is instead we just told

00:00:46.140 --> 00:00:51.090
here is a data set can you find some

00:00:48.780 --> 00:00:52.890
structure in the data given this data

00:00:51.090 --> 00:00:55.559
set an unsupervised learning algorithm

00:00:52.890 --> 00:00:57.930
might decide that the data lives in two

00:00:55.559 --> 00:01:00.090
different clusters so there's one

00:00:57.930 --> 00:01:02.609
cluster and there's a different cluster

00:01:00.090 --> 00:01:04.710
and the unsupervised learning algorithm

00:01:02.609 --> 00:01:07.350
may break this data into these two

00:01:04.710 --> 00:01:09.479
separate clusters so this is called a

00:01:07.350 --> 00:01:12.450
clustering algorithm and this turns out

00:01:09.479 --> 00:01:15.000
to be used in many places one example

00:01:12.450 --> 00:01:16.710
where clustering is used is in Google

00:01:15.000 --> 00:01:18.390
News and if you're not seeing this

00:01:16.710 --> 00:01:21.450
before you can actually go to this URL

00:01:18.390 --> 00:01:23.700
news.google.com to take a look what

00:01:21.450 --> 00:01:25.110
Google News does is every day it goes

00:01:23.700 --> 00:01:26.790
and looks at tens of thousands or

00:01:25.110 --> 00:01:29.250
hundreds of thousands of new stories on

00:01:26.790 --> 00:01:32.600
the web and it groups them into cohesive

00:01:29.250 --> 00:01:37.259
news stories for example let's look here

00:01:32.600 --> 00:01:41.400
the URLs here link to different news

00:01:37.259 --> 00:01:43.200
stories about the BP oil well story so

00:01:41.400 --> 00:01:45.450
let's say I click on one of these URLs

00:01:43.200 --> 00:01:47.189
and I click on one of these URLs what

00:01:45.450 --> 00:01:49.140
I'll get to is a web page like this

00:01:47.189 --> 00:01:52.049
here's a Wall Street Journal article

00:01:49.140 --> 00:01:55.020
about you know the BP oil wells still

00:01:52.049 --> 00:01:58.290
stories of BP cause Macondo which is the

00:01:55.020 --> 00:02:01.619
name of the un-- scope and if you click

00:01:58.290 --> 00:02:02.909
on a different URL from that group then

00:02:01.619 --> 00:02:05.880
you might get the different story

00:02:02.909 --> 00:02:09.000
she's a CNN story about again the BP oil

00:02:05.880 --> 00:02:10.470
spill and if you click on get a third

00:02:09.000 --> 00:02:13.140
link that you might get

00:02:10.470 --> 00:02:17.490
a different story here's the UK Guardian

00:02:13.140 --> 00:02:18.840
story about the BP oil spill so a Google

00:02:17.490 --> 00:02:20.310
News is done is looked at tens of

00:02:18.840 --> 00:02:23.160
thousands of new stories and

00:02:20.310 --> 00:02:25.440
automatically cluster them together so

00:02:23.160 --> 00:02:28.620
the new stories that are all about the

00:02:25.440 --> 00:02:30.600
same topic get to display together it

00:02:28.620 --> 00:02:32.190
turns out that clustering algorithms and

00:02:30.600 --> 00:02:34.490
unsupervised learning algorithms are

00:02:32.190 --> 00:02:37.430
used in many other problems as well

00:02:34.490 --> 00:02:40.710
here's one on understanding genomics

00:02:37.430 --> 00:02:42.930
here's an example of DNA microarray data

00:02:40.710 --> 00:02:45.000
the idea is you have a group of

00:02:42.930 --> 00:02:47.400
different individuals and for each of

00:02:45.000 --> 00:02:49.770
them you measure how much they do or do

00:02:47.400 --> 00:02:51.390
not have a certain gene technically you

00:02:49.770 --> 00:02:55.170
measure how much of certain genes are

00:02:51.390 --> 00:02:57.540
expressed so these colors red green gray

00:02:55.170 --> 00:02:59.910
and so on they show the degree to which

00:02:57.540 --> 00:03:03.390
different individuals do or do not have

00:02:59.910 --> 00:03:05.340
a specific gene and what you can do is

00:03:03.390 --> 00:03:07.290
then run a clustering algorithm to group

00:03:05.340 --> 00:03:10.560
individuals into different categories

00:03:07.290 --> 00:03:12.090
onto different types of people so this

00:03:10.560 --> 00:03:13.560
is unsupervised learning because we're

00:03:12.090 --> 00:03:15.600
not telling the algorithm in advance

00:03:13.560 --> 00:03:17.910
that you know these are Taiwan people

00:03:15.600 --> 00:03:20.610
those are type 2 persons those are type

00:03:17.910 --> 00:03:22.290
3 persons and so on and instead what

00:03:20.610 --> 00:03:24.239
we're saying is you know here's a bunch

00:03:22.290 --> 00:03:26.459
of data I don't know what's in this data

00:03:24.239 --> 00:03:27.810
I don't know who's in what type I didn't

00:03:26.459 --> 00:03:29.790
know what the different types of people

00:03:27.810 --> 00:03:31.019
are but can you automatically find

00:03:29.790 --> 00:03:33.000
structure in the data from you

00:03:31.019 --> 00:03:34.650
automatically cluster the individuals

00:03:33.000 --> 00:03:36.930
into these types that I don't know in

00:03:34.650 --> 00:03:40.070
advance because we're not giving them

00:03:36.930 --> 00:03:42.480
the algorithm the right answer for the

00:03:40.070 --> 00:03:44.700
examples in my data set this is

00:03:42.480 --> 00:03:46.590
unsupervised learning unsupervised

00:03:44.700 --> 00:03:48.810
learning or clustering is used for a

00:03:46.590 --> 00:03:51.600
bunch of other applications is used to

00:03:48.810 --> 00:03:53.100
organize large computer clusters I had

00:03:51.600 --> 00:03:54.870
some friends looking at large data

00:03:53.100 --> 00:03:56.760
centers that there's large computer

00:03:54.870 --> 00:03:59.250
clusters and trying to figure out which

00:03:56.760 --> 00:04:01.200
machines tend to work together and if

00:03:59.250 --> 00:04:03.209
you can put those machines together you

00:04:01.200 --> 00:04:06.030
can make your data center work more

00:04:03.209 --> 00:04:08.340
efficiently your second application on

00:04:06.030 --> 00:04:10.170
social network analysis so given

00:04:08.340 --> 00:04:12.150
knowledge about which friends you email

00:04:10.170 --> 00:04:13.739
the most or given your Facebook friends

00:04:12.150 --> 00:04:16.410
or your Google+ Circles

00:04:13.739 --> 00:04:19.080
can we automatically identify which are

00:04:16.410 --> 00:04:20.729
cohesive groups of friends so what are

00:04:19.080 --> 00:04:21.880
groups of people that all know each

00:04:20.729 --> 00:04:25.460
other

00:04:21.880 --> 00:04:27.110
market segmentation many companies have

00:04:25.460 --> 00:04:29.120
huge databases of customer information

00:04:27.110 --> 00:04:31.520
so can you look at this customer data

00:04:29.120 --> 00:04:33.800
set and automatically discover market

00:04:31.520 --> 00:04:36.770
segments and automatically group your

00:04:33.800 --> 00:04:39.680
customers into different market segments

00:04:36.770 --> 00:04:42.020
so that you can automatically and more

00:04:39.680 --> 00:04:44.540
efficiently sell or market to your

00:04:42.020 --> 00:04:46.460
different market segments together again

00:04:44.540 --> 00:04:48.560
this is unsupervised learning because we

00:04:46.460 --> 00:04:49.880
have all this customer data but we don't

00:04:48.560 --> 00:04:52.220
know in advance what are the market

00:04:49.880 --> 00:04:53.690
segments and for the customers in our

00:04:52.220 --> 00:04:55.970
data set you know we don't know in

00:04:53.690 --> 00:04:58.040
advance who is in microsecond one who is

00:04:55.970 --> 00:04:59.870
in market segments two and so on but we

00:04:58.040 --> 00:05:02.570
have to let the algorithm discover all

00:04:59.870 --> 00:05:04.820
this just from the data finally it turns

00:05:02.570 --> 00:05:07.940
out that unsupervised learning is also

00:05:04.820 --> 00:05:10.280
used for surprisingly astronomical data

00:05:07.940 --> 00:05:12.200
analysis and these clustering algorithms

00:05:10.280 --> 00:05:15.380
give surprisingly interesting or useful

00:05:12.200 --> 00:05:18.590
theories of how galaxies are formed all

00:05:15.380 --> 00:05:20.450
these are examples of clustering which

00:05:18.590 --> 00:05:22.250
is just one type of unsupervised

00:05:20.450 --> 00:05:24.050
learning let me tell you about another

00:05:22.250 --> 00:05:27.140
one I'm going to tell you about the

00:05:24.050 --> 00:05:28.820
cocktail party problem so we've been the

00:05:27.140 --> 00:05:30.980
cocktail parties before right where you

00:05:28.820 --> 00:05:32.930
can imagine there's a party room for

00:05:30.980 --> 00:05:34.700
people all sitting around all talk at

00:05:32.930 --> 00:05:36.620
the same time and there are all these

00:05:34.700 --> 00:05:38.300
overlapping voices because everyone's

00:05:36.620 --> 00:05:39.919
talked in the same time and it's almost

00:05:38.300 --> 00:05:44.000
hard to hear the person in front of you

00:05:39.919 --> 00:05:47.030
so maybe have a cocktail party with two

00:05:44.000 --> 00:05:50.240
people two people talking the same time

00:05:47.030 --> 00:05:52.669
and someone small cocktail party and

00:05:50.240 --> 00:05:55.190
we're going to put two microphones in

00:05:52.669 --> 00:05:57.500
the room so there are microphones and

00:05:55.190 --> 00:05:59.419
because these microphones are at two

00:05:57.500 --> 00:06:02.480
different distances from the speaker's

00:05:59.419 --> 00:06:05.180
each microphone records a different

00:06:02.480 --> 00:06:07.880
combination of these two speakers voices

00:06:05.180 --> 00:06:10.460
maybe speaker one is a little louder in

00:06:07.880 --> 00:06:12.200
microphone one and maybe speaker two is

00:06:10.460 --> 00:06:14.180
a little bit louder in microphone two

00:06:12.200 --> 00:06:16.010
because you know the two microphones are

00:06:14.180 --> 00:06:20.390
at different positions relative to the 2

00:06:16.010 --> 00:06:22.610
speakers but each microphone recalls an

00:06:20.390 --> 00:06:23.300
overlapping combination of both speakers

00:06:22.610 --> 00:06:26.830
voices

00:06:23.300 --> 00:06:29.680
so here's an here's an actual recording

00:06:26.830 --> 00:06:31.720
two speakers recorded by a researcher

00:06:29.680 --> 00:06:34.660
let me play for you the first one the

00:06:31.720 --> 00:06:42.160
first microphone sounds like one two

00:06:34.660 --> 00:06:44.260
three one my head alright maybe not the

00:06:42.160 --> 00:06:46.330
most interesting cocktail party is two

00:06:44.260 --> 00:06:48.160
people counting from one to ten in two

00:06:46.330 --> 00:06:50.110
languages that you know there you go

00:06:48.160 --> 00:06:52.540
what you just heard was the first

00:06:50.110 --> 00:07:02.590
microphone recording here's the second

00:06:52.540 --> 00:07:04.540
recording you see the names so we can do

00:07:02.590 --> 00:07:06.100
is take these two microphone recordings

00:07:04.540 --> 00:07:07.750
and give them to an unsupervised

00:07:06.100 --> 00:07:10.210
learning algorithm called the cocktail

00:07:07.750 --> 00:07:13.360
party algorithm and tell the algorithm

00:07:10.210 --> 00:07:15.730
find structure in this data for me and

00:07:13.360 --> 00:07:18.310
what the album will do is listen to

00:07:15.730 --> 00:07:20.470
these audio recordings and say you know

00:07:18.310 --> 00:07:22.570
it sounds like the two audio recordings

00:07:20.470 --> 00:07:24.340
that being added together or there being

00:07:22.570 --> 00:07:26.920
some together to produce these

00:07:24.340 --> 00:07:28.630
recordings that we had moreover what the

00:07:26.920 --> 00:07:30.880
cocktail party algorithm will do is

00:07:28.630 --> 00:07:33.250
separate out these two audio sources

00:07:30.880 --> 00:07:35.620
that were being added or being summed

00:07:33.250 --> 00:07:37.750
together to form our recordings and in

00:07:35.620 --> 00:07:41.440
fact here's the first output of the

00:07:37.750 --> 00:07:47.430
cocktail party algorithm one two three

00:07:41.440 --> 00:07:50.500
oh five six seven eight nine ten so

00:07:47.430 --> 00:07:52.240
separated out the English voice in one

00:07:50.500 --> 00:07:56.220
of us in one of the recordings and

00:07:52.240 --> 00:08:00.850
here's the second output uno dos tres

00:07:56.220 --> 00:08:04.180
cuatro Cinco seis fifty all true really

00:08:00.850 --> 00:08:06.400
it is not too bad to give you one more

00:08:04.180 --> 00:08:08.380
example here's another recording of

00:08:06.400 --> 00:08:10.980
another similar situation here's the

00:08:08.380 --> 00:08:10.980
first microphone

00:08:16.310 --> 00:08:20.450
okay so the poor guys gone home from the

00:08:18.620 --> 00:08:23.210
cocktail party and he's now studying the

00:08:20.450 --> 00:08:26.710
route by himself talking to his video he

00:08:23.210 --> 00:08:26.710
has the second microphone recording

00:08:32.479 --> 00:08:36.659
when you give these two microphone

00:08:34.349 --> 00:08:39.000
recording to the same algorithm what it

00:08:36.659 --> 00:08:41.219
does is again say you know it sounds

00:08:39.000 --> 00:08:44.099
like there are two audio sources and

00:08:41.219 --> 00:08:45.810
moreover the album says here is the

00:08:44.099 --> 00:08:50.759
first of the audio sources

00:08:45.810 --> 00:08:55.350
I found one two three four five six

00:08:50.759 --> 00:08:57.630
seven eight nine ten so that wasn't

00:08:55.350 --> 00:09:00.029
perfect it got the boys but they'll also

00:08:57.630 --> 00:09:01.380
go up into the music in there then

00:09:00.029 --> 00:09:03.860
here's the second output of the

00:09:01.380 --> 00:09:03.860
algorithm

00:09:08.840 --> 00:09:13.760
II not too bad in that second output and

00:09:11.960 --> 00:09:16.160
managed to get rid of the voice entirely

00:09:13.760 --> 00:09:18.980
and just Co cleaned up the music and got

00:09:16.160 --> 00:09:20.990
rid of the counting from one to ten so

00:09:18.980 --> 00:09:23.240
you might look at an unsupervised

00:09:20.990 --> 00:09:25.310
learning algorithm like this and ask how

00:09:23.240 --> 00:09:27.350
complicated is it to implement this it

00:09:25.310 --> 00:09:29.300
seems like in order to you know build

00:09:27.350 --> 00:09:29.630
this application it seems like to do

00:09:29.300 --> 00:09:31.310
this

00:09:29.630 --> 00:09:33.770
audio processing you need to write a ton

00:09:31.310 --> 00:09:35.900
of code or maybe link into like a bunch

00:09:33.770 --> 00:09:37.310
of C++ or Java libraries to process

00:09:35.900 --> 00:09:39.650
audio it seems like an really

00:09:37.310 --> 00:09:41.590
complicated program to do this audio

00:09:39.650 --> 00:09:44.450
separating out audio and so on

00:09:41.590 --> 00:09:47.180
it turns out the algorithm to do what

00:09:44.450 --> 00:09:51.170
you just heard that can be done with one

00:09:47.180 --> 00:09:53.480
line of code shown right here it did

00:09:51.170 --> 00:09:55.190
take me searches a long time to come up

00:09:53.480 --> 00:09:57.680
with this line of code so I'm not saying

00:09:55.190 --> 00:09:58.970
this is an easy problem but it turns out

00:09:57.680 --> 00:10:01.400
that we use the right programming

00:09:58.970 --> 00:10:04.340
environment many learning algorithms can

00:10:01.400 --> 00:10:06.380
be really short programs so this is also

00:10:04.340 --> 00:10:09.200
why in this class we're going to use the

00:10:06.380 --> 00:10:11.720
octave programming environment octave is

00:10:09.200 --> 00:10:14.480
free open source software and using a

00:10:11.720 --> 00:10:16.430
tool like octave or MATLAB many learning

00:10:14.480 --> 00:10:18.620
algorithms become just a few lines of

00:10:16.430 --> 00:10:20.570
code to implement later in this class

00:10:18.620 --> 00:10:22.670
also teach you a little bit about how to

00:10:20.570 --> 00:10:24.920
use octave and you'll be implementing

00:10:22.670 --> 00:10:27.380
some of these albums in octave or if you

00:10:24.920 --> 00:10:29.090
have MATLAB you can use that - turns out

00:10:27.380 --> 00:10:31.250
that Silicon Valley for a lot of machine

00:10:29.090 --> 00:10:33.740
learning algorithms what we do is first

00:10:31.250 --> 00:10:35.360
prototype our software in octave because

00:10:33.740 --> 00:10:37.430
software that octave makes it incredibly

00:10:35.360 --> 00:10:39.860
fast implement these learning algorithms

00:10:37.430 --> 00:10:42.800
here are each of these functions like

00:10:39.860 --> 00:10:44.390
for example the SVD function that sends

00:10:42.800 --> 00:10:46.790
the singular value decomposition but

00:10:44.390 --> 00:10:48.860
that turns out to be a linear algebra

00:10:46.790 --> 00:10:51.170
routine that is just built into octave

00:10:48.860 --> 00:10:53.150
if you were trying to do this a C++ or

00:10:51.170 --> 00:10:55.160
Java this would be many many lines of

00:10:53.150 --> 00:10:57.740
code linking complex C++ or Java

00:10:55.160 --> 00:10:59.960
libraries so you can implement this

00:10:57.740 --> 00:11:01.700
stuff in C++ or Java or Python there's

00:10:59.960 --> 00:11:04.280
just much more complicated to use to do

00:11:01.700 --> 00:11:06.260
some of those languages what I've seen

00:11:04.280 --> 00:11:08.840
after having taught machine learning for

00:11:06.260 --> 00:11:11.600
almost about a decade now is that you

00:11:08.840 --> 00:11:14.570
learn much faster if you use octave as

00:11:11.600 --> 00:11:17.150
your programming environment and if you

00:11:14.570 --> 00:11:19.610
use octave as your learning tool and as

00:11:17.150 --> 00:11:21.050
your prototyping tool I'll let you learn

00:11:19.610 --> 00:11:23.210
and prototype learning

00:11:21.050 --> 00:11:25.760
rooms much more quickly and in fact what

00:11:23.210 --> 00:11:27.740
many people will do in the large Silicon

00:11:25.760 --> 00:11:29.960
Valley companies is in fact use an

00:11:27.740 --> 00:11:32.270
algorithm like octave to first prototype

00:11:29.960 --> 00:11:33.860
the learning algorithm and only after

00:11:32.270 --> 00:11:37.040
you've gotten to where and then you

00:11:33.860 --> 00:11:38.690
migrate it to C++ or Java or whatever it

00:11:37.040 --> 00:11:40.370
turns out that by doing things this way

00:11:38.690 --> 00:11:42.500
you can often get your algorithm to work

00:11:40.370 --> 00:11:45.950
much faster than if you were starting

00:11:42.500 --> 00:11:48.620
out in C++ so I know that this instruct

00:11:45.950 --> 00:11:50.360
as an instructor I get to say trust me

00:11:48.620 --> 00:11:52.100
on this one only a finite number of

00:11:50.360 --> 00:11:54.380
times but for those of you who have

00:11:52.100 --> 00:11:55.970
never used these octave type programming

00:11:54.380 --> 00:11:58.190
environments before I'm going to answer

00:11:55.970 --> 00:12:01.100
there trust me on this one and say that

00:11:58.190 --> 00:12:02.510
you you will I think your time when you

00:12:01.100 --> 00:12:05.780
develop a time is one of the most

00:12:02.510 --> 00:12:07.640
valuable resources and having seen lots

00:12:05.780 --> 00:12:09.770
of people do this I think you as a

00:12:07.640 --> 00:12:11.510
machine learning researcher or machine

00:12:09.770 --> 00:12:13.070
learning developer will be much more

00:12:11.510 --> 00:12:15.020
productive if you learn to stuff in

00:12:13.070 --> 00:12:20.360
prototype to stuff in octave and in some

00:12:15.020 --> 00:12:22.940
of the language finally to wrap up this

00:12:20.360 --> 00:12:25.520
video have one quick review question for

00:12:22.940 --> 00:12:27.530
you we talked about unsupervised

00:12:25.520 --> 00:12:28.850
learning which is the learning setting

00:12:27.530 --> 00:12:31.280
where you give the algorithm a ton of

00:12:28.850 --> 00:12:33.860
data and just ask it to find structure

00:12:31.280 --> 00:12:36.770
in the data for us of the following four

00:12:33.860 --> 00:12:38.570
examples which ones which of these four

00:12:36.770 --> 00:12:40.880
do you think would be an unsupervised

00:12:38.570 --> 00:12:43.580
learning out algorithm as opposed to a

00:12:40.880 --> 00:12:45.230
supervised learning problem for each of

00:12:43.580 --> 00:12:48.280
the four check boxes on the Left check

00:12:45.230 --> 00:12:50.300
the ones or which you think of

00:12:48.280 --> 00:12:52.520
unsupervised learning algorithm would be

00:12:50.300 --> 00:12:54.800
appropriate and then click the button on

00:12:52.520 --> 00:12:57.860
the lower right to check your answer so

00:12:54.800 --> 00:13:02.570
when the video pauses please answer the

00:12:57.860 --> 00:13:04.970
question on the slide so hopefully

00:13:02.570 --> 00:13:07.640
remember the spam filter problem if you

00:13:04.970 --> 00:13:09.470
have labeled data you know with of spam

00:13:07.640 --> 00:13:12.110
and non-spam email we treat this as a

00:13:09.470 --> 00:13:15.170
supervised learning problem the new

00:13:12.110 --> 00:13:16.760
story example that's exactly the Google

00:13:15.170 --> 00:13:18.710
News example that we saw in this video

00:13:16.760 --> 00:13:20.570
we saw how you can use a clustering

00:13:18.710 --> 00:13:22.390
algorithm to cluster news articles

00:13:20.570 --> 00:13:25.790
together so that's unsurprising learning

00:13:22.390 --> 00:13:27.740
the market segmentation example I talked

00:13:25.790 --> 00:13:30.410
a little bit earlier do that as an

00:13:27.740 --> 00:13:31.270
unsupervised learning problem because

00:13:30.410 --> 00:13:33.490
I'm just going to give my

00:13:31.270 --> 00:13:36.339
from data and ask you to discover market

00:13:33.490 --> 00:13:38.529
segments automatically and the final

00:13:36.339 --> 00:13:41.020
example diabetes well that's actually

00:13:38.529 --> 00:13:41.740
just like our breast cancer example from

00:13:41.020 --> 00:13:43.959
the last video

00:13:41.740 --> 00:13:46.080
only instead of you know good and bad

00:13:43.959 --> 00:13:49.390
cancer tumors or benign and malignant

00:13:46.080 --> 00:13:51.610
tumors we instead have have diabetes or

00:13:49.390 --> 00:13:53.500
not and so we will use that as a

00:13:51.610 --> 00:13:55.420
supervised we will solve that as a

00:13:53.500 --> 00:13:58.870
supervised learning problem just like we

00:13:55.420 --> 00:14:01.600
did for the breast tumor data so that's

00:13:58.870 --> 00:14:03.390
it for unsupervised learning and in the

00:14:01.600 --> 00:14:06.100
next video we'll delve more into

00:14:03.390 --> 00:14:08.170
specific learning algorithms and start

00:14:06.100 --> 00:14:10.510
to talk about just how these algorithms

00:14:08.170 --> 00:14:13.440
work and how we can how you can go about

00:14:10.510 --> 00:14:13.440
implementing them
