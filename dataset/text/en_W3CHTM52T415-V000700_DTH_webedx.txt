Hi! Now we are preparing ourselves for reading the content of the different text tracks and display them. But before that, I must introduce what we call the TextTrack object that is a JavaScript object that is associated to the HTML elements. A track has two different views... maybe it is simpler to say that it has got a HTML view that means you can do a getElementById and manipulate the HTML element, this track element here, from JavaScript.  Or we can also work with its twin brother that is a text track, and this new view is the one we are going to use for forcing a track to be loaded, and for reading its content. And also for forcing subtitles or caption track to be displayed. So we just slightly modify the previous example by displaying the mode The mode is a property from the TextTrack, not from the HTML track. And this mode can be "disabled", "showing" or "hidden". And when it is disabled, reading the video will not fire any event related to the track. We will talk about events later but a disabled track is the same if we have no track at all. A track that is "showing" is displayed in the video, if the implementation of the video player supports that. And a track that is "hidden" is just not displayed. So how did we manipulated and accessed this mode property? The displayTrackStatuses function, that we wrote earlier, displayed the different properties of the HTML track, like the label, the kind or the language. This time, we accessed his twin brother, the TextTrack by using the track property. Every HTML track element has a track property that is a TextTrack. So here, from the current HTML track, I am getting the TextTrack (currentTextTrack). This is the object we use to access the mode and display it here. Another interesting thing is that if we set the mode, if we modify the value of the mode, from "disabled" to "showing" or to "hidden", it will force the track to be loaded asynchronously in the background by the browser. So we added in this example two buttons, "force load track 0" and "force load track 2" because by default, the track 0, the English subtitles, is not loaded. And the chapters, in track number 2, are not loaded either. We are going to force the track 0 to be loaded. If I click here "force load track 0", you see that the status changes - the mode changes to "hidden" and the track now is loaded. So what happened in the background? Let's have a look at the code we wrote. So I am going to zoom a little bit... The button we clicked is this one: "force load track 0" here, called a function named forceLoadTrack(0) that I prepared. What does this function do? It will call another function called getTrack that will check if the track is already loaded. If it is already loaded, then the second parameter here, is a callback function, It will be called because the track is ready to be read. In the case the track has not been loaded, we will set the mode to "hidden" and then we will trigger the browser so that it will load asynchronously, in the background, the track. And when the track is ready, then, and only then, we will call readContent. Let's have a look at this getTrack function that we wrote. It says getTrack, please load me the TextTracks corresponding to the HTML track number n. So here is the function. The first thing we do is that from the HTML track, we get the text track. Then we check on the HTML track if it is already loaded. If it is the case, then we will call the function that has been passed as the second parameter: it's the readContent. And the readContent is just here, for the moment it will not read the content really, but it will just update the status. So if I click on « force load track 2 » for example, it will load the track and when the track is arrived, it will call the displayStatus() that will show the updated status of the track. In the case the track is not here, the readyState is not equal to 2, then we will force the track to be loaded. By doing this we set the mode to "hidden". This may will take some time: you understand that the browser is loading on the Web the track. It may take 2 seconds for example. So we need to have a listener that will listen to the load event. So htmlTrack.addEventListenner('load'...) will trigger only when the track has been loaded, and only in that case we will call the callback function: the readContent that has been passed in the second parameter, in order to read the track. If I look at the console, and if I start again the application. Only the second track has been loaded, I click "force load track 0", it says "forcing the track to be loaded", it loads the track and it calls the callback "reading content of loaded track". If I click again the same button, it says "the text track is already loaded" and I am going to read it now. We cannot load a track several times, if it is already loaded, we must just use it. In the next video, we will show how we can effectively read the content of the track and do something with it.